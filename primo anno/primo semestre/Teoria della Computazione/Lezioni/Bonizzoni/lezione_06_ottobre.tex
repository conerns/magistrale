\section{Lezione del 6 ottobre - Bonizzoni}
\subsection{Problemmi di decisione}
La teoria della \textbf{complessità computazionale} si riferisce a varie \textbf{classi di complessità} che classificano, in un primo approccio, \textit{problemi decisionali} descritti da funzioni binarie che hanno in input una stringa sull'alfabeto $\{0,1\}$ e restituiscono un bit (0,1). 
Sia $\Pi$ un problema di decisione 
\begin{itemize}
    \item \textbf{input}: $x$ istanza, $|x| = n$ 
    \item \textbf{output}: $0$ (NO), $1$ (YES)
\end{itemize} La funzione $f_{\Pi}$ associata a $\Pi$ è: $f_{\Pi} : \{0,1\}^* \to \{0,1\}$. Questo perché le macchine di Turing ragionano in binario. 

\textbf{Esistono problemi che si è dimostrato non essere risolvibili in tempo efficiente.}\\ Tra le classi abbiamo i \textbf{problemi NP} e \textbf{problemi P}. Inoltre i problemi NP sono a loro volta classificabili tra loro cercando i più difficili, ottenendo \textbf{problemi NP-hard} e \textbf{problemi NP-complete} (esistono varie dimostrazioni per la \textit{NP-completezza}). 

\subsection{Tempo di calcolo di una TM} 
 Sia $T:\mathbb{N} \to \mathbb{N}$ una funzione calcolabile da TM e $L_\Pi$ un linguaggio di decisione (dove $\pi$ sta per problema e di decisione ci ricorda che il risultato sarà binario), allora una \textbf{TM deterministica} $M$ accetta (risponde $1$, YES) $L_\Pi$ in tempo $T(n)$ se, $\forall x\in L_\pi$, con $|x|=n$, $M$ accetta $x$ in $T(n)$ mosse o configurazioni.
 
 Un \textbf{problema di decisione} $\pi$ riceve in input un'istanza $x$ e l'output è: 
 \begin{itemize} 
    \item 0 che vuole dire \textit{no} 
    \item 1 che vuole dire \textit{yes} 
\end{itemize} 

Un linguaggio $L_\Pi$ restituisce 1 per tutti gli $x$ che appartengono al linguaggio. Quindi $L_\Pi$ è l'insieme degli input di $\pi$ su cui l'output è 1.\\ 
La \textbf{funzione associata al problema} si chiama $f_\pi$ ed è la funzione che dato un input restituisce 1 sse l'input appartiene al $L_\Pi$.  \\
La classe dei linguaggi di decisione accettati in tempo $T(n)=cn^p \quad p\in\mathbb{N}, \quad p\neq 0$ da una TM deterministica è detta \textbf{classe P}. \\ 
Potenzialmente $p$ potrebbe anche non essere un intero in quanto si potrebbero avere tempi frazionari e non polinomiali. Si definisce che $L_\Pi$ è accettato da una TM in tempo $T(n)$ se $\exists \,\,T :\mathbb{N}\to \mathbb{N}$ calcolabile da TM e $\forall x\in L_\Pi$, con $|x|=n$, la TM accetta $x$ e risponde 1 (\textit{yes}) in al più $T(n)$ mosse di calcolo (dette anche configurazioni).\\ 

Se $y \notin L_\Pi$, siccome è stato fissato un limite di tempo $T(n)$, allora è possibile costruire una macchina $M'$ che accetta il complemento del linguaggio $L_\Pi$. Infatti $\exists M' |$ se $y \notin L_{\Pi}$ è input, questa impiega $T(n)$ per dire che $y \notin L_{\Pi}$. \\
Complemento di $L_\Pi = \{y \: | \: f_\Pi (y) = 0\}$ \\
La macchina $M'$ simula $M$ su input $y$ e se dopo $T(n)$ mosse su input $y$, con $|y| = n$ non è stata accettato $y$, allora $M'$ va nello stato finale con $0$ in output.

\subsection{Macchina RAM}
Nel caso del modello della macchina RAM si ha la stessa situazione con però $T(n)$ \textbf{istruzioni RAM} e si dice che $L_\Pi$ è accettato dalla macchina RAM (si può dire che è anche deciso dell'algoritmo A della macchina RAM). In caso contrario la macchina RAM restituisce \textit{no}, in quanto si parla di ``decisione'' oltre che di ``accettazione'' (a differenza della TM, dove però si può ottenere lo stesso discorso parlando di TM complementare $M'$, che in $T(n)$ mi risponderà yes alla richiesta che un input non appartenga a $L_\Pi$, altrimenti bisogna fissare un limite di tempo per ottenere yes).\\ È dimostrabile che se $L_\Pi$ è accettabile in tempo polinomiale allora nello stesso tempo è anche decidibile.\\ La differenza tra accettazione e decisione sarà fondamentale nel \textbf{modello non deterministico}.  

Si ricordi che il \textbf{modello RAM (\textit{Random Access Machine})} è usato per studiare il tempo di calcolo di uno pseudocodice. È un modello teorico (una macchina teorica ``simile'' a quelle reali) dotato di istruzioni come \textit{load, store, add, etc$\ldots$} dove un codice (ipoteticamente in qualsiasi linguaggio incluso lo pseudocodice) viene tradotto in una sorta di linguaggio macchina (linguaggio RAM), dove $n$ è un intero rappresentante il numero di istruzioni RAM necessarie per ottenere l'output ($n$ è detto \textbf{tempo uniforme}). Sul linguaggio RAM si può studiare anche lo spazio calcolato come numero di bit necessari per la computazione (è detto \textbf{costo logaritmico}). In questo secondo punto il costo di un'istruzione, come ad esempio \textit{load(n)}, è logaritmico rispetto all'operando $n$ ($\,\log_2 n$), studia quindi la \emph{dimensione} dell'input.  
